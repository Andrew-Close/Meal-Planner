type: edu
files:
  - name: build.gradle
    visible: true
    text: |
      repositories {
          mavenCentral()
      }
      
      dependencies {
          implementation 'org.postgresql:postgresql:42.2.27'
      }
    learner_created: false
  - name: test/MealPlannerTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.hyperskill.hstest.testing.TestedProgram;
      
      import java.io.File;
      import java.sql.*;
      import java.util.*;
      
      class Column {
        public String first;
        public String second;
      
        public Column(String first, String second) {
          this.first = first;
          this.second = second;
        }
      
        @Override
        public boolean equals(Object o) {
          if (this == o) return true;
          if (o == null || getClass() != o.getClass()) return false;
          Column column = (Column) o;
          return Objects.equals(first, column.first) && Objects.equals(second, column.second);
        }
      
        @Override
        public int hashCode() {
          return Objects.hash(first, second);
        }
      }
      
      class dbTable {
        String name;
        List<Column> columnNameType;
      
        public dbTable(String name, List<Column> columnNameType) {
          this.name = name;
          this.columnNameType = columnNameType;
        }
      }
      
      class MyMealTestData {
        String mealCategory;
        String mealName;
        String[] ingredients;
      
        MyMealTestData(String mealCategory, String mealName, String[] ingredients) {
          this.mealCategory = mealCategory;
          this.mealName = mealName;
          this.ingredients = ingredients;
        }
      }
      
      public class MealPlannerTests extends StageTest {
      
        static final String DB_URL = "jdbc:postgresql:meals_db";
        static final String USER = "postgres";
        static final String PASS = "1111";
      
        String[] days = new String[]{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
      
        static final MyMealTestData[] mealsList = new MyMealTestData[]{
                new MyMealTestData("breakfast", "scrambled eggs", new String[]{"eggs", "milk", "cheese"}),
                new MyMealTestData("breakfast", "sandwich", new String[]{"bread", "cheese", "ham"}),
                new MyMealTestData("breakfast", "oatmeal", new String[]{"oats", "milk", "banana", "peanut butter"}),
                new MyMealTestData("breakfast", "english breakfast", new String[]{"eggs", "sausages", "bacon", "tomatoes",
                        "bread"}),
                new MyMealTestData("lunch", "sushi", new String[]{"salmon", "rice", "avocado"}),
                new MyMealTestData("lunch", "chicken salad", new String[]{"chicken", "lettuce", "tomato", "olives"}),
                new MyMealTestData("lunch", "omelette", new String[]{"eggs", "milk", "cheese"}),
                new MyMealTestData("lunch", "salad", new String[]{"lettuce", "tomato", "onion", "cheese", "olives"}),
                new MyMealTestData("dinner", "pumpkin soup", new String[]{"pumpkin", "coconut milk", "curry", "carrots"}),
                new MyMealTestData("dinner", "beef steak", new String[]{"beef steak"}),
                new MyMealTestData("dinner", "pizza", new String[]{"flour", "tomato", "cheese", "salami"}),
                new MyMealTestData("dinner", "tomato soup", new String[]{"tomato", "orzo"})
        };
      
        void checkTableSchema(List<dbTable> tables) {
          try {
            Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);
            DatabaseMetaData meta = connection.getMetaData();
            for (dbTable table : tables) {
              ResultSet tableMeta = meta.getTables(null, null, table.name, null);
              if (!tableMeta.next() || !table.name.equalsIgnoreCase(tableMeta.getString("TABLE_NAME"))) {
                throw new WrongAnswer("The table \"" + table.name + "\" doesn't exist.");
              }
              ResultSet columns = meta.getColumns(null, null, table.name, null);
              List<Column> columnsData = new ArrayList<>();
              while (columns.next()) {
                Column column = new Column(
                        columns.getString("COLUMN_NAME").toLowerCase(),
                        columns.getString("TYPE_NAME").toLowerCase());
                columnsData.add(column);
              }
              for (Column c : table.columnNameType) {
                if (!columnsData.contains(c)) {
                  for (Column c2 : columnsData) {
                    if (c.first.equals(c2.first)) {
                      throw new WrongAnswer("The column \"" + c.first + "\" of the table \"" + table.name + "\" is of the " +
                              "wrong type.");
                    }
                  }
                  throw new WrongAnswer("The column \"" + c.first + "\" of the table \"" + table.name + "\" doesn't exist.");
                }
              }
            }
            connection.close();
          } catch (Exception e) {
            throw new WrongAnswer("An exception was thrown, while trying to check the database schema - " + e.getMessage());
          }
        }
      
        void checkConnection() {
          try {
            Class.forName("org.postgresql.Driver");
          } catch (ClassNotFoundException e) {
            throw new WrongAnswer("An exception was thrown, while trying to connect to database. PostgreSQL JDBC Driver is " +
                    "not found.");
          }
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (SQLException e) {
            throw new WrongAnswer("An exception was thrown, while trying to connect to database. Connection Failed");
          }
      
          if (connection == null) {
            throw new WrongAnswer("Failed to make connection to database");
          }
        }
      
        @DynamicTest(order = 0)
        public CheckResult normalExe21Test() {
      
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          CheckOutput co = new CheckOutput();
          if (!co.start("What would you like to do (add, show, plan, save, exit)?"))
            return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, save," +
                    " exit)?\"");
          ArrayList<dbTable> tables = new ArrayList<>(Arrays.asList(
                  new dbTable("ingredients", new ArrayList<>(
                          Arrays.asList(
                                  new Column("ingredient", "varchar"),
                                  new Column("ingredient_id", "int4"),
                                  new Column("meal_id", "int4")
                          )
                  )),
                  new dbTable("meals", new ArrayList<>(
                          Arrays.asList(
                                  new Column("category", "varchar"),
                                  new Column("meal", "varchar"),
                                  new Column("meal_id", "int4")
                          )
                  ))
          ));
          checkTableSchema(tables);
      
          if (!co.input("save", "Unable to save. Plan your meals first."))
            return CheckResult.wrong("Your output should contain \"Unable to save. Plan your meals first.\"");
      
          if (!co.input("exit", "Bye!"))
            return CheckResult.wrong("Your output should contain \"Bye!\"");
          if (!co.programIsFinished())
            return CheckResult.wrong("The application didn't exit.");
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 1)
        public CheckResult normalExe16Test() {
      
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          CheckOutput co = new CheckOutput();
          if (!co.start("What would you like to do (add, show, plan, save, exit)?"))
            return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, save," +
                    " exit)?\"");
          ArrayList<dbTable> tables = new ArrayList<>(Arrays.asList(
                  new dbTable("ingredients", new ArrayList<>(
                          Arrays.asList(
                                  new Column("ingredient", "varchar"),
                                  new Column("ingredient_id", "int4"),
                                  new Column("meal_id", "int4")
                          )
                  )),
                  new dbTable("meals", new ArrayList<>(
                          Arrays.asList(
                                  new Column("category", "varchar"),
                                  new Column("meal", "varchar"),
                                  new Column("meal_id", "int4")
                          )
                  ))
          ));
          checkTableSchema(tables);
      
          if (!co.input("exit", "Bye!"))
            return CheckResult.wrong("Your output should contain \"Bye!\"");
          if (!co.programIsFinished())
            return CheckResult.wrong("The application didn't exit.");
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 2)
        CheckResult normalExe17Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, dinner)" +
                      "?\"");
      
            if (!co.input("lunch", "Input the meal's name:"))
              return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
            if (!co.input("sushi", "Input the ingredients:"))
              return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
            if (!co.input("salmon, rice, avocado", "The meal has been added!"))
              return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, dinner)" +
                      "?\"");
      
            if (!co.input("lunch", "Input the meal's name:"))
              return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
            if (!co.input("omelette", "Input the ingredients:"))
              return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
            if (!co.input("eggs, milk, cheese", "The meal has been added!"))
              return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, dinner)" +
                      "?\"");
      
            if (!co.input("breakfast", "Input the meal's name:"))
              return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
            if (!co.input("oatmeal", "Input the ingredients:"))
              return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
            if (!co.input("oats, milk, banana, peanut butter", "The meal has been added!"))
              return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("lunch", "Category: lunch", "Name: sushi", "Ingredients:", "salmon", "rice", "avocado",
                    "Name: omelette", "Ingredients:", "eggs", "milk", "cheese"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("breakfast", "Category: breakfast", "Name: oatmeal", "Ingredients:", "oats",
                    "milk", "banana", "peanut butter"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - " + e);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 3)
        CheckResult normalExe18Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("lunch", "Category: lunch", "Name: sushi", "Ingredients:", "salmon", "rice", "avocado",
                    "Name: omelette", "Ingredients:", "eggs", "milk", "cheese"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("breakfast", "Category: breakfast", "Name: oatmeal", "Ingredients:", "oats",
                    "milk", "banana", "peanut butter"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("brunch", "Wrong meal category! Choose from: breakfast, lunch, dinner."))
              return CheckResult.wrong("Wrong output after the input of a category that doesn't exist.");
      
            if (!co.input("dinner", "No meals found."))
              return CheckResult.wrong("Wrong output for a category with no added meals.");
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - " + e);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 4)
        CheckResult normalExe19Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "save, " +
                      "exit)?\"");
      
      
            for (MyMealTestData meal : mealsList) {
              if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
                return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, " +
                        "dinner)?\"");
      
              if (!co.input(meal.mealCategory, "Input the meal's name:"))
                return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
              if (!co.input(meal.mealName, "Input the ingredients:"))
                return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
              if (!co.input(String.join(",", meal.ingredients), "The meal has been added!"))
                return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
              if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
                return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                        "save, " +
                        "exit)?\"");
      
            }
      
            co.getNextOutput("plan");
            int index = 0;
            for (String day : days) {
              if (!co.inputNext(day))
                return CheckResult.wrong("Your output should contain \"" + day + "\"");
      
              String[] categories = new String[]{"breakfast", "lunch", "dinner"};
              String[][] alphabetic = {
                      new String[]{"english breakfast", "oatmeal", "sandwich", "scrambled eggs"},
                      new String[]{"chicken salad", "omelette", "salad", "sushi"},
                      new String[]{"beef steak", "pizza", "pumpkin soup", "tomato soup"}
              };
              for (int i = 0; i < 3; i++) {
                String category = categories[i];
                if (!co.inputNext(alphabetic[i]))
                  return CheckResult.wrong("Make sure that formatting of your output is similar to the one in the example. " +
                          "Also, your output should contain the meals in alphabetic order.");
      
                if (!co.inputNext("Choose the " + category + " for " + day + " from the list above:"))
                  return CheckResult.wrong("Your output should contain the prompt for the " + category + " meal.");
      
                if (!co.input("nonExistMeal", "This meal doesn’t exist. Choose a meal from the list above."))
                  return CheckResult.wrong("Your output should contain \"This meal doesn’t exist. Choose a meal from the " +
                          "list above.\"");
      
                co.getNextOutput(((MyMealTestData) (Arrays.stream(mealsList).filter(x -> x.mealCategory.equals(category)).toArray()[index % 4])).mealName);
              }
              if (!co.inputNext("Yeah! We planned the meals for " + day + "."))
                return CheckResult.wrong("Your output should contain \"Yeah! We planned the meals for " + day + ".\".");
              index++;
            }
      
            String[] planPrintout = new String[]{"Monday", "Breakfast: scrambled eggs", "Lunch: sushi", "Dinner: pumpkin " +
                    "soup",
                    "Tuesday", "Breakfast: sandwich", "Lunch: chicken salad", "Dinner: beef steak",
                    "Wednesday", "Breakfast: oatmeal", "Lunch: omelette", "Dinner: pizza",
                    "Thursday", "Breakfast: english breakfast", "Lunch: salad", "Dinner: tomato soup",
                    "Friday", "Breakfast: scrambled eggs", "Lunch: sushi", "Dinner: pumpkin soup",
                    "Saturday", "Breakfast: sandwich", "Lunch: chicken salad", "Dinner: beef steak",
                    "Sunday", "Breakfast: oatmeal", "Lunch: omelette", "Dinner: pizza"};
      
            for (String line : planPrintout) {
              if (!co.inputNext(line))
                return CheckResult.wrong("Your output should contain \"" + line + "\".");
            }
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
      
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - " + e);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 5)
        CheckResult normalExe20Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong(
                      "Your program should ask the user about the required action: \"(add, show, plan, save, exit)?\"");
      
            if (!co.input("save", "Input a filename:"))
              return CheckResult.wrong("Your output should contain: \"Input a filename:\"");
      
            if (!co.input("plan.txt", "Saved!"))
              return CheckResult.wrong("Your output should contain: \"Saved!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, save, exit)?"))
              return CheckResult.wrong(
                      "Your program should ask the user about the required action: \"(add, show, plan, save, exit)?\"");
      
            File ingredientsFile = new File("plan.txt");
            if (!ingredientsFile.exists())
              return CheckResult.wrong("The ingredient file doesn't exist.");
      
            List<String> ingredientsInPlan = new ArrayList<>(List.of(
                    "avocado x2", "bacon", "banana x2", "beef steak x2", "bread x3", "carrots x2",
                    "cheese x9", "chicken x2", "coconut milk x2", "curry x2", "eggs x5",
                    "flour x2", "ham x2", "lettuce x3", "milk x6", "oats x2", "olives x3",
                    "onion", "orzo", "peanut butter x2", "pumpkin x2", "rice x2", "salami x2",
                    "salmon x2", "sausages", "tomato x6", "tomatoes"));
            Scanner scanner = new Scanner(ingredientsFile);
            while(scanner.hasNext()){
              String line = scanner.nextLine();
              if (!ingredientsInPlan.contains(line))
                return CheckResult.wrong("There is no ingredient \""+line+"\" in plan");
              ingredientsInPlan.remove(line);
            }
            if(!ingredientsInPlan.isEmpty())
              return CheckResult.wrong("Ingredient \""+ingredientsInPlan.get(0)+"\" doesn't exist in file.");
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - "+e);
          }
      
          return CheckResult.correct();
        }
      }
      
      
      class CheckOutput {
        private TestedProgram main = new TestedProgram();
        private int position = 0;
        private boolean caseInsensitive = true;
        private boolean trimOutput = true;
        private List<String> arguments = new ArrayList<>();
        private boolean isStarted = false;
        private String lastOutput = "";
      
        private boolean checkOutput(String outputString, String... checkStr) {
          int searchPosition = position;
          for (String cStr : checkStr) {
            String str = caseInsensitive ? cStr.toLowerCase() : cStr;
            int findPosition = outputString.indexOf(str, searchPosition);
            if (findPosition == -1) return false;
            if (!outputString.substring(searchPosition, findPosition).isBlank()) return false;
            searchPosition = findPosition + str.length();
          }
          position = searchPosition;
          return true;
        }
      
        public boolean start(String... checkStr) {
          if (isStarted)
            return false;
          var outputString = main.start(arguments.toArray(new String[]{}));
          lastOutput = outputString;
          if (trimOutput) outputString = outputString.trim();
          if (caseInsensitive) outputString = outputString.toLowerCase();
          isStarted = true;
          return checkOutput(outputString, checkStr);
        }
      
        public void stop() {
          main.stop();
        }
      
        public boolean input(String input, String... checkStr) {
          if (main.isFinished()) return false;
          String outputString = main.execute(input);
          lastOutput = outputString;
          if (trimOutput) outputString = outputString.trim();
          if (caseInsensitive) outputString = outputString.toLowerCase();
          position = 0;
          return checkOutput(outputString, checkStr);
        }
      
        public boolean inputNext(String... checkStr) {
          String outputString = lastOutput;
          if (trimOutput) outputString = outputString.trim();
          if (caseInsensitive) outputString = outputString.toLowerCase();
          return checkOutput(outputString, checkStr);
        }
      
        public String getNextOutput(String input) {
          if (main.isFinished()) return "";
          String outputString = main.execute(input);
          lastOutput = outputString;
          position = 0;
          return outputString;
        }
      
        public String getLastOutput() {
          return lastOutput;
        }
      
        public boolean programIsFinished() {
          return main.isFinished();
        }
      
        public void setArguments(String... arguments) {
          this.arguments = Arrays.stream(arguments).toList();
        }
      
        public void setCaseInsensitive(boolean caseInsensitive) {
          this.caseInsensitive = caseInsensitive;
        }
      
        public void setTrimOutput(boolean trimOutput) {
          this.trimOutput = trimOutput;
        }
      }
    learner_created: false
  - name: src/mealplanner/datamanager/dao/plan/Plan.java
    visible: true
    text: |
      package mealplanner.meal.datamanager.dao.plan;
      
      /**
       * This is just a class for holding fields for the plan for the database
       */
      public class Plan {
          String category;
          String meal;
          int meal_id;
          String day;
      
          public Plan(String category, String meal, int meal_id, String day) {
              this.category = category;
              this.meal = meal;
              this.meal_id = meal_id;
              this.day = day;
          }
      
          String getCategory() {
              return category;
          }
      
          String getMeal() {
              return meal;
          }
      
          int getMeal_id() {
              return meal_id;
          }
      
          String getDay() {
              return day;
          }
      
          @Override
          public String toString() {
              return "Plan{" +
                      "category='" + category + '\'' +
                      ", meal='" + meal + '\'' +
                      ", meal_id=" + meal_id +
                      ", day='" + day + '\'' +
                      '}';
          }
      }
    learner_created: true
  - name: src/mealplanner/main/MealUserInput.java
    visible: true
    text: |
      package mealplanner.main;
      
      import java.util.Scanner;
      import java.util.regex.Matcher;
      import java.util.regex.Pattern;
      
      /**
       * This class is specific to this program. It gets valid user input, but the methods are specific to what this program needs.
       */
      
      public class MealUserInput {
          /**
           * This enum ensures that user input for what operation to do is correct
           */
          private enum Operations {
              ADD("add"), SHOW("show"), EXIT("exit"), PLAN("plan");
              private final String operation;
      
              Operations(String operation) {
                  this.operation = operation;
              }
      
              private String getOperation() {
                  return this.operation;
              }
          }
      
          /**
           * This enum ensures that user input for a meal category is correct
           */
          public enum Categories {
              BREAKFAST("breakfast"), LUNCH("lunch"), DINNER("dinner");
              private final String category;
      
              Categories(String category) {
                  this.category = category;
              }
      
              public String getCategory() {
                  return this.category;
              }
          }
      
          private static final Scanner scanner = new Scanner(System.in);
      
          /**
           * Gets a valid operation from user input. Will keep looping until the user inputs a valid operation
           * @return = the operation
           */
          static String getValidOperation() {
              while (true) {
                  String operation = scanner.nextLine();
                  for (Operations enumOperation : Operations.values()) {
                      if (enumOperation.getOperation().equals(operation)) {
                          return operation;
                      }
                  }
                  System.out.println(Main.getOperationMessage());
              }
          }
      
          /**
           * Gets a valid meal category from user input. Will keep looping until the user inputs a valid category
           * @return = the category
           */
          static String getValidCategory() {
              while (true) {
                  String category = scanner.nextLine();
                  for (Categories enumCategory : Categories.values()) {
                      if (enumCategory.getCategory().equals(category)) {
                          return category;
                      }
                  }
                  System.out.println("Wrong meal category! Choose from: breakfast, lunch, dinner.");
              }
          }
      
          /**
           * Gets a valid array of ingredients from user input. Will keep looping until the user inputs a valid ingredients array
           * @return = the array of ingredients
           */
          static String[] getValidIngredients() {
              // This regex matches anything other than letters and whitespace. So if it matches anything in the input, the input is wrong
              String lettersRegex = "[^a-zA-Z\\s]";
              // This regex matches anything other than whitespace. So if it matches nothing in the input, the input is wrong
              String emptyRegex = "\\S";
              // Pattern for the letters regex
              Pattern lettersPattern = Pattern.compile(lettersRegex);
              // Pattern for the empty regex
              Pattern emptyPattern = Pattern.compile(emptyRegex);
              whileloop:
              while (true) {
                  String userInputString = scanner.nextLine();
                  // Checks the corner case of there being a comma at the end of the input
                  if (userInputString.length() >= 2) {
                      if (userInputString.substring(userInputString.length() - 2).matches(",|, ")) {
                          System.out.println("Wrong format. Use letters only!");
                          continue;
                      }
                  }
                  String[] userInput = userInputString.split(", |,");
                  for (String ingredient : userInput) {
                      Matcher lettersMatcher = lettersPattern.matcher(ingredient);
                      Matcher emptyMatcher = emptyPattern.matcher(ingredient);
                      // Checks each element in the split array rather than the entire inputted string
                      if (lettersMatcher.find() || !emptyMatcher.find()) {
                          System.out.println("Wrong format. Use letters only!");
                          continue whileloop;
                      }
                  }
                  return userInput;
              }
          }
      
          /**
           * Gets user input for a valid meal which is in the meals array. Will keep looping until a valid meal in inputted
           * @param meals the array containing all the valid meals
           * @return the user input meal
           */
          static String getValidMealUsingArray(String[] meals) {
              while (true) {
                  String choice = scanner.nextLine();
                  for (String meal : meals) {
                      if (meal.equalsIgnoreCase(choice)) {
                          return choice;
                      }
                  }
                  System.out.println("This meal doesn’t exist. Choose a meal from the list above.");
              }
          }
      }
    learner_created: true
  - name: src/mealplanner/userinput/UserInput.java
    visible: true
    text: |-
      package mealplanner.userinput;
      
      import java.util.Scanner;
      import java.util.regex.Matcher;
      import java.util.regex.Pattern;
      
      /**
       * This class is a general purpose class for getting user input. Methods can be customized with custom error messages
       */
      public class UserInput {
          private static final Scanner scanner = new Scanner(System.in);
      
          /**
           * Gets a string consisting of just letters and whitespace. Will keep looping until the user inputs a correct string
           * @return = the string, as long as it is valid
           */
          public static String getAlphabeticalString(String errorMessage) {
              // This regex matches anything other than letters and whitespace. So if it matches anything in the input, the input is wrong
              String lettersRegex = "[^a-zA-Z\\s]";
              // This regex matches anything other than whitespace. So if it matches nothing in the input, the input is wrong
              String emptyRegex = "\\S";
              // Pattern for the letters regex
              Pattern lettersPattern = Pattern.compile(lettersRegex);
              // Pattern for the empty regex
              Pattern emptyPattern = Pattern.compile(emptyRegex);
              while (true) {
                  String userInput = scanner.nextLine();
                  Matcher lettersMatcher = lettersPattern.matcher(userInput);
                  Matcher emptyMatcher = emptyPattern.matcher(userInput);
                  if (lettersMatcher.find() || !emptyMatcher.find()) {
                      System.out.println(errorMessage);
                      continue;
                  }
                  return userInput;
              }
          }
      }
    learner_created: true
  - name: src/mealplanner/datamanager/dao/plan/DbPlanDao.java
    visible: true
    text: |
      package mealplanner.meal.datamanager.dao.plan;
      
      import java.sql.SQLException;
      import java.util.List;
      
      /**
       * This class interfaces directly with the user, allowing them access to basic CRUD operations. This class uses a client to send queries to the database
       */
      public class DbPlanDao implements PlanDao {
          private final DbPlanClient client;
      
          public DbPlanDao() {
              client = new DbPlanClient();
          }
      
          @Override
          public List<Plan> findAll() throws SQLException {
              return client.selectForList("SELECT * FROM plan");
          }
      
          @Override
          public Plan find(String category, String day) throws SQLException {
              return client.select(String.format("SELECT * FROM plan WHERE category = '%s' AND day = '%s'", category, day));
          }
      
          @Override
          public void add(Plan plan) throws SQLException {
              client.run(String.format("INSERT INTO plan VALUES('%s', '%s', %d, '%s')", plan.getCategory(), plan.getMeal(), plan.getMeal_id(), plan.getDay()));
          }
      
          @Override
          public void update(Plan plan) throws SQLException {
              client.run(String.format("UPDATE plan SET meal = '%s', meal_id = %d WHERE category = '%s' AND day = '%s'", plan.getMeal(), plan.getMeal_id(), plan.getCategory(), plan.getDay()));
          }
      
          @Override
          public void delete(int id) throws SQLException {
              client.run(String.format("DELETE FROM plan WHERE meal_id = %d", id));
          }
      
          @Override
          public void deleteAll() throws SQLException {
              client.run("DELETE FROM plan");
          }
      }
    learner_created: true
  - name: src/mealplanner/datamanager/dao/plan/DbPlanClient.java
    visible: true
    text: |
      package mealplanner.meal.datamanager.dao.plan;
      
      import org.postgresql.ds.PGSimpleDataSource;
      
      import java.sql.*;
      import java.util.ArrayList;
      import java.util.List;
      
      /**
       * This class handles everything to do with connecting to the database and executing passed queries for the plans table. The DAO itself doesn't actually execute queries. Rather, it passes queries
       * to this object to be executed.
       */
      public class DbPlanClient {
          private final PGSimpleDataSource dataSource;
      
          public DbPlanClient() {
              String DB_URL = "jdbc:postgresql:meals_db";
              String USER = "postgres";
              String PASS = "1111";
              this.dataSource = new PGSimpleDataSource();
              dataSource.setURL(DB_URL);
              dataSource.setUser(USER);
              dataSource.setPassword(PASS);
          }
      
          public void run(String query) throws SQLException {
              try (Connection connection = dataSource.getConnection();
               Statement statement = connection.createStatement()) {
                  statement.executeUpdate(query);
              } catch (SQLException e) {
                  throw new SQLException(e);
              }
          }
      
          public Plan select(String query) throws SQLException {
              List<Plan> plans = selectForList(query);
              if (plans.size() == 1) {
                  return plans.get(0);
              } else if (plans.isEmpty()) {
                  return null;
              } else {
                  throw new IllegalStateException("Query returned more than one object");
              }
          }
      
          public List<Plan> selectForList(String query) throws SQLException {
              List<Plan> plans = new ArrayList<>();
              try (Connection connection = dataSource.getConnection();
                  PreparedStatement statement = connection.prepareStatement(query);
                   ResultSet result = statement.executeQuery()
              ) {
                  while (result.next()) {
                      String category = result.getString("category");
                      String meal = result.getString("meal");
                      int meal_id = result.getInt("meal_id");
                      String day = result.getString("day");
                      plans.add(new Plan(category, meal, meal_id, day));
                  }
                  return plans;
              } catch (SQLException e) {
                  throw new SQLException(e);
              }
          }
      }
    learner_created: true
  - name: src/mealplanner/datamanager/dao/plan/PlanDao.java
    visible: true
    text: |
      package mealplanner.meal.datamanager.dao.plan;
      
      import java.sql.SQLException;
      import java.util.List;
      
      /**
       * This is an interface for dao's for the plan table
       */
      public interface PlanDao {
          List<Plan> findAll() throws SQLException;
          Plan find(String category, String day) throws SQLException;
          void add(Plan plan) throws SQLException;
          void update(Plan plan) throws SQLException;
          void delete(int id) throws SQLException;
          void deleteAll() throws SQLException;
      }
    learner_created: true
  - name: src/mealplanner/datamanager/legacydatamanager/DataManager.java
    visible: true
    text: |
      package mealplanner.meal.datamanager.legacydatamanager;
      
      import mealplanner.main.MealUserInput;
      import org.postgresql.ds.PGSimpleDataSource;
      import org.apache.commons.lang3.StringUtils;
      
      import java.sql.Connection;
      import java.sql.PreparedStatement;
      import java.sql.ResultSet;
      import java.sql.SQLException;
      import java.util.ArrayList;
      import java.util.List;
      
      /**
       * This class manages the meal database. It lets you get data, insert data, modify data, and read data, among other things
       */
      public class DataManager {
          /**
           * This enum is used to ensure that correct tables which exist are being chosen
           */
          public enum Tables {
              MEALS, INGREDIENTS
          }
      
          /**
           * Initializes the required tables if they don't already exist at the beginning of the runtime
           */
          public static void initializeTables() {
              try (Connection connection = connect()) {
                  String mealsTableCreation = "CREATE TABLE IF NOT EXISTS meals (" +
                                                  "category VARCHAR(9)," +
                                                  "meal VARCHAR(50)," +
                                                  "meal_id INTEGER" +
                                              ")";
                  String ingredientsTableCreation = "CREATE TABLE IF NOT EXISTS ingredients (" +
                                                          "ingredient VARCHAR(50)," +
                                                          "ingredient_id INTEGER," +
                                                          "meal_id INTEGER" +
                                                      ")";
                  String planTableCreation = "CREATE TABLE IF NOT EXISTS plan (" +
                                                  "category VARCHAR(9)," +
                                                  "meal VARCHAR(50)," +
                                                  "meal_id INTEGER," +
                                                  "day VARCHAR(9)" +
                                              ")";
                  try (PreparedStatement mealsTableStatement = connection.prepareStatement(mealsTableCreation);
                       PreparedStatement ingredientsTableStatement = connection.prepareStatement(ingredientsTableCreation);
                       PreparedStatement planTableStatement = connection.prepareStatement(planTableCreation)) {
                      // Initialization
                      mealsTableStatement.execute();
                      ingredientsTableStatement.execute();
                      planTableStatement.execute();
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
          }
      
          /**
           * Returns a ResultSet of all the columns from the specified table
           * @param table the name of the table which the user wishes to select data from
           * @return the ResultSet from the specified table
           */
          @Deprecated
          public static ResultSet getAllColumns(Tables table) {
              try (Connection connection = connect()) {
                  if (table.equals(Tables.MEALS)) {
                      String selection = "SELECT * FROM meals";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(selection)) {
                          return preparedStatement.executeQuery();
                      } catch (SQLException ignored) {
                      }
                  } else if (table.equals(Tables.INGREDIENTS)) {
                      String selection = "SELECT * FROM ingredients";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(selection)) {
                          return preparedStatement.executeQuery();
                      } catch (SQLException ignored) {
                      }
                  }
      
              } catch (SQLException ignored) {
              }
              return null;
          }
      
          /**
           * Returns all the data in the meals table in the specified category as a string for use with the show operation.
           * @param category the category in which only meals from that category are read
           */
          public static String getMealsMessage(String category) {
              StringBuilder message = new StringBuilder();
              // Keeps track of how many meals there are so the spacing is correct. If there is only one meal, there should not be any padding. If there is more than one meal, there should be padding
              int mealCounter = 0;
              // Points to where to place the padding in-between the category and the first name if there is more than one meal
              int firstPaddingPointer = 0;
              try (Connection connection = connect()) {
                  String mealSelection = "SELECT * FROM meals WHERE category = '" + category + "'";
                  String ingredientSelection = "SELECT * FROM ingredients WHERE meal_id = ? ORDER BY ingredient_id";
                  try (PreparedStatement mealStatement = connection.prepareStatement(mealSelection); PreparedStatement ingredientStatement = connection.prepareStatement(ingredientSelection)) {
                      // Result of meal selection
                      try (ResultSet mealData = mealStatement.executeQuery()) {
                          message.append("Category: ").append(category).append("\n");
                          // Places the pointer in-between the category and the first name
                          firstPaddingPointer = message.length();
                          while (mealData.next()) {
                              ++mealCounter;
                              message.append("Name: ").append(mealData.getString("meal")).append("\n");
                              message.append("Ingredients: \n");
                              ingredientStatement.setInt(1, mealData.getInt("meal_id"));
                              try (ResultSet ingredientData = ingredientStatement.executeQuery()) {
                                  while (ingredientData.next()) {
                                      message.append(ingredientData.getString("ingredient")).append("\n");
                                  }
                              } catch (Exception ignored) {
                              }
                              message.append("\n");
                          }
                      } catch (SQLException ignored) {
                      }
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
              // Adds finishing touches to the message based on how many meals there are
              if (mealCounter == 0) {
                  return "No meals found.";
              } else if (mealCounter == 1) {
                  // Removes all the padding at the end of the message so the message is flush with the next operation request
                  message.delete(message.length() - 2, message.length());
              } else {
                  // Adds the first padding at the pointer
                  message.insert(firstPaddingPointer, "\n");
                  // Deletes the extra newline so there aren't two newlines at the end
                  message.delete(message.length() - 1, message.length());
              }
              return message.toString();
          }
      
          /**
           * Gets a String representation of the entire plan for the week for use with the plan operation
           * @return the String representation of plan
           */
          public static String getPlanMessage() throws SQLException {
              StringBuilder message = new StringBuilder();
              try (Connection connection = connect();
                  PreparedStatement statement = connection.prepareStatement("SELECT * FROM plan");
                  ResultSet result = statement.executeQuery()
              ) {
                  result.next();
                  for (int i = 0; i < 7; i++) {
                      message.append(StringUtils.capitalize(result.getString("day"))).append("\n");
                      for (int j = 0; j < 3; j++) {
                          message.append(StringUtils.capitalize(result.getString("category"))).append(": ").append(result.getString("meal")).append("\n");
                          result.next();
                      }
                      message.append("\n");
                  }
                  // Deletes the trailing newline. The result is only one newline at the end rather than two
                  message.delete(message.length() - 1, message.length());
              } catch (SQLException e) {
                  throw new SQLException(e);
              }
              return message.toString();
          }
      
          /**
           * Inserts passed data into the specified table. Uses the Tables enum to specify which table it should insert the data into. The data is parsed differently depending on which table it is being
           * put into
           * @param table the table that the user wants to insert data into
           * @param values a string array consisting of all data the user wants to insert
           */
          public static void insertInto(Tables table, String[] values) {
              try (Connection connection = connect()) {
                  // If the passed table is the meals table, then the data is parsed specially for that table
                  if (table.equals(Tables.MEALS)) {
                      String insert = "INSERT INTO meals VALUES(?, ?, ?)";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(insert)) {
                          preparedStatement.setString(1, values[0]);
                          preparedStatement.setString(2, values[1]);
                          preparedStatement.setInt(3, Integer.parseInt(values[2]));
                          preparedStatement.executeUpdate();
                      } catch (SQLException e) {
                          e.getMessage();
                      }
                  // If the passed table is the ingredients table, then the data is parsed specially for that table
                  } else if (table.equals(Tables.INGREDIENTS)) {
                      String insert = "INSERT INTO ingredients VALUES(?, ?, ?)";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(insert)) {
                          preparedStatement.setString(1, values[0]);
                          preparedStatement.setInt(2, Integer.parseInt(values[1]));
                          preparedStatement.setInt(3, Integer.parseInt(values[2]));
                          preparedStatement.executeUpdate();
                      } catch (SQLException e) {
                          e.getMessage();
                      }
                  }
              } catch (SQLException e) {
                  e.getMessage();
              }
          }
      
          /**
           * Gets all meals in the passed category and returns them as a string array. The meals will be in alphabetical order
           * @param category the category from which to get the meals
           * @return the string array of the meals
           * @throws SQLException;
           */
          public static String[] getMealsAlphabeticalOrder(String category) throws SQLException {
              String query;
              // The message which will be returned
              List<String> meals = new ArrayList<>();
              // Checks which category was passed and sets the query accordingly
              if (category.equalsIgnoreCase(MealUserInput.Categories.BREAKFAST.getCategory())) {
                  query = "SELECT meal FROM meals WHERE category = 'breakfast' ORDER BY meal";
              } else if (category.equalsIgnoreCase(MealUserInput.Categories.LUNCH.getCategory())) {
                  query = "SELECT meal FROM meals WHERE category = 'lunch' ORDER BY meal";
              } else if (category.equalsIgnoreCase(MealUserInput.Categories.DINNER.getCategory())) {
                  query = "SELECT meal FROM meals WHERE category = 'dinner' ORDER BY meal";
              } else {
                  throw new IllegalArgumentException("The passed category was incorrect. It needs to be either \"breakfast\", \"lunch\", or \"dinner\". Case does not matter.");
              }
              try (Connection connection = connect();
                  PreparedStatement statement = connection.prepareStatement(query);
                  ResultSet result = statement.executeQuery()
              ) {
                  while (result.next()) {
                      meals.add(result.getString("meal"));
                  }
              } catch (SQLException e) {
                  throw new SQLException(e.getMessage());
              }
              String[] array = new String[meals.size()];
              for (int i = 0; i < meals.size(); i++) {
                  array[i] = meals.get(i);
              }
              return array;
          }
      
          /**
           * Takes the name of a saved meal and returns the corresponding meal_id
           * @param mealName the meal name to get the meal_id from
           * @return the meal_id of the meal
           */
          public static int getMealIDFromName(String mealName) {
              String query = String.format(
                      "SELECT meal_id FROM meals WHERE UPPER(meal) = UPPER('%s')", mealName
              );
              try (Connection connection = connect();
                  PreparedStatement statement = connection.prepareStatement(query);
                  ResultSet result = statement.executeQuery()
              ) {
                  result.next();
                  return result.getInt("meal_id");
              } catch (SQLException e) {
                  throw new RuntimeException(e);
              }
          }
      
          /**
           * Gets the next meal id to be used when adding a meal to the database
           * @return the meal id
           */
          public static int getNextMealID() {
              try (Connection connection = connect()) {
                  String selection = "SELECT MAX(meal_id) FROM meals";
                  try (PreparedStatement statement = connection.prepareStatement(selection)) {
                      try (ResultSet result = statement.executeQuery()) {
                          result.next();
                          return result.getInt("max") + 1;
                      } catch (SQLException ignored) {
                      }
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
              return 0;
          }
      
          /**
           * Gets the next ingredient id to be used when adding an ingredient to the database
           * @return the ingredient id
           */
          public static int getNextIngredientID() {
              try (Connection connection = connect()) {
                  String selection = "SELECT MAX(ingredient_id) FROM ingredients";
                  try (PreparedStatement statement = connection.prepareStatement(selection)) {
                      try (ResultSet result = statement.executeQuery()) {
                          result.next();
                          return result.getInt("max") + 1;
                      } catch (SQLException ignored) {
                      }
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
              return 0;
          }
      
          /**
           * Returns a connection object to be used in other methods. Needs to be used to a try-catch block because one is not used here
           * @return the connection object
           * @throws SQLException;
           */
          private static Connection connect() throws SQLException {
              String DB_URL = "jdbc:postgresql:meals_db";
              String USER = "postgres";
              String PASS = "1111";
              PGSimpleDataSource dataSource = new PGSimpleDataSource();
              dataSource.setURL(DB_URL);
              dataSource.setUser(USER);
              dataSource.setPassword(PASS);
              return dataSource.getConnection(USER, PASS);
          }
      }
    learner_created: true
  - name: src/mealplanner/main/Main.java
    visible: true
    text: |-
      package mealplanner.main;
      
      import mealplanner.meal.datamanager.dao.plan.DbPlanDao;
      import mealplanner.meal.datamanager.dao.plan.Plan;
      import mealplanner.meal.datamanager.legacydatamanager.DataManager;
      import mealplanner.userinput.UserInput;
      
      import java.sql.SQLException;
      
      public class Main {
        private static final DbPlanDao planDao = new DbPlanDao();
        private static final String operationMessage = "What would you like to do (add, show, plan, exit)?";
        public static void main(String[] args) throws SQLException {
          // Since the test gets rid of all tables at the start of execution, I need to initialize the tables if they don't already exist
          DataManager.initializeTables();
          // The user input loop
          inputLoop();
        }
      
        /**
         * This is the loop for getting user input and performing actions
         */
        private static void inputLoop() throws SQLException {
          // The while loop uses this boolean as the condition, so when this boolean is set to false, the loop terminates
          boolean shouldContinue = true;
          while (shouldContinue) {
            //String message = DataManager.getMessage();
            // Caches the message
            System.out.println(operationMessage);
            String operation = MealUserInput.getValidOperation();
            switch (operation) {
              case "add":
                addMeal();
                break;
              case "show":
                showMeals();
                break;
              case "plan":
                planMeals();
                break;
              case "exit":
                shouldContinue = false;
                System.out.println("Bye!");
            }
          }
        }
      
        /**
         * Adds a new meal to the savedMeals ArrayList. Uses user input classes to get valid input
         */
        private static void addMeal() {
          System.out.println("Which meal do you want to add (breakfast, lunch, dinner)?");
          String category = MealUserInput.getValidCategory();
          System.out.println("Input the meal's name:");
          String name = UserInput.getAlphabeticalString("Wrong format. Use letters only!");
          System.out.println("Input the ingredients:");
          String[] ingredients = MealUserInput.getValidIngredients();
          String mealID = Integer.toString(DataManager.getNextMealID());
          DataManager.insertInto(DataManager.Tables.MEALS, new String[]{category, name, mealID});
          for (String ingredient : ingredients) {
            DataManager.insertInto(DataManager.Tables.INGREDIENTS, new String[]{ingredient, Integer.toString(DataManager.getNextIngredientID()), mealID});
          }
          System.out.println("The meal has been added!");
        }
      
        /**
         * Shows all meals in the category specified by the user
         */
        private static void showMeals() {
          System.out.println("Which category do you want to print (breakfast, lunch, dinner)?");
          System.out.println(DataManager.getMealsMessage(MealUserInput.getValidCategory()));
        }
      
        /**
         * Goes through the planning process to plan meals for each category for each day of the week
         */
        private static void planMeals() throws SQLException {
          planDao.deleteAll();
          // Iterates through each of the days
          for (int i = 1; i <= 7; i++) {
            String day;
            day = getDayFromIteration(i);
            System.out.println(day);
            // Iterates through each of the categories
            for (int j = 1; j <= 3; j++) {
              // Current day
              // Current category
              String category = getCategoryFromIteration(j);
              // The meals from the current category
              String[] meals = DataManager.getMealsAlphabeticalOrder(category);
              for (String meal : meals) System.out.println(meal);
              System.out.printf("Choose the %s for %s from the list above:%n", category.toLowerCase(), day);
              // Gets user input for a meal which is in the meals array
              String choice = MealUserInput.getValidMealUsingArray(meals);
              planDao.add(new Plan(category.toLowerCase(), choice, DataManager.getMealIDFromName(choice), day.toLowerCase()));
            }
            System.out.printf("Yeah! We planned the meals for %s.%n%n", day);
          }
          System.out.println(DataManager.getPlanMessage());
        }
      
        /**
         * A method to be used with the planMeals method which returns the day corresponding to the iteration of the for loop in the planMeals method, 1-7
         * @param i the iteration
         * @return the day
         */
        private static String getDayFromIteration(int i) {
            return switch (i) {
                case 1 -> "Monday";
                case 2 -> "Tuesday";
                case 3 -> "Wednesday";
                case 4 -> "Thursday";
                case 5 -> "Friday";
                case 6 -> "Saturday";
                case 7 -> "Sunday";
                default -> "Null";
            };
        }
      
        /**
         * A method to be used with the planMeals method which returns the category corresponding to the iteration of the for loop in the planMeals method, 1-3
         * @param i the iteration
         * @return the category
         */
        private static String getCategoryFromIteration(int i) {
          return switch (i) {
            case 1 -> "Breakfast";
            case 2 -> "Lunch";
            case 3 -> "Dinner";
            default -> "Null";
          };
        }
      
        public static String getOperationMessage() {
          return operationMessage;
        }
      }
    learner_created: true
  - name: src/shoppinglist/test.txt
    visible: true
    learner_created: true
  - name: src/shoppinglist/shoppinglist.txt
    visible: true
    learner_created: true
  - name: src/shoppinglist/list.txt
    visible: true
    learner_created: true
  - name: src/shoppinglist/plan.txt
    visible: true
    learner_created: true
  - name: plan.txt
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/25576#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Sat, 30 Mar 2024 20:07:58 UTC"
record: -1
