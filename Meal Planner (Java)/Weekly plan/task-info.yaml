type: edu
files:
  - name: build.gradle
    visible: true
    text: |
      repositories {
          mavenCentral()
      }
      
      dependencies {
          implementation 'org.postgresql:postgresql:42.2.27'
      }
    learner_created: false
  - name: test/MealPlannerTests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.dynamic.DynamicTest;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.hyperskill.hstest.testing.TestedProgram;
      
      import java.sql.*;
      import java.util.*;
      
      class Column {
        public String first;
        public String second;
      
        public Column(String first, String second) {
          this.first = first;
          this.second = second;
        }
      
        @Override
        public boolean equals(Object o) {
          if (this == o) return true;
          if (o == null || getClass() != o.getClass()) return false;
          Column column = (Column) o;
          return Objects.equals(first, column.first) && Objects.equals(second, column.second);
        }
      
        @Override
        public int hashCode() {
          return Objects.hash(first, second);
        }
      }
      
      class dbTable {
        String name;
        List<Column> columnNameType;
      
        public dbTable(String name, List<Column> columnNameType) {
          this.name = name;
          this.columnNameType = columnNameType;
        }
      }
      
      class MyMealTestData {
        String mealCategory;
        String mealName;
        String[] ingredients;
      
        MyMealTestData(String mealCategory, String mealName, String[] ingredients) {
          this.mealCategory = mealCategory;
          this.mealName = mealName;
          this.ingredients = ingredients;
        }
      }
      
      public class MealPlannerTests extends StageTest {
      
        static final String DB_URL = "jdbc:postgresql:meals_db";
        static final String USER = "postgres";
        static final String PASS = "1111";
      
        String[] days = new String[]{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
      
        static final MyMealTestData[] mealsList = new MyMealTestData[]{
                new MyMealTestData("breakfast", "scrambled eggs", new String[]{"eggs", "milk", "cheese"}),
                new MyMealTestData("breakfast", "sandwich", new String[]{"bread", "cheese", "ham"}),
                new MyMealTestData("breakfast", "oatmeal", new String[]{"oats", "milk", "banana", "peanut butter"}),
                new MyMealTestData("breakfast", "english breakfast", new String[]{"eggs", "sausages", "bacon", "tomatoes",
                        "bread"}),
                new MyMealTestData("lunch", "sushi", new String[]{"salmon", "rice", "avocado"}),
                new MyMealTestData("lunch", "chicken salad", new String[]{"chicken", "lettuce", "tomato", "olives"}),
                new MyMealTestData("lunch", "omelette", new String[]{"eggs", "milk", "cheese"}),
                new MyMealTestData("lunch", "salad", new String[]{"lettuce", "tomato", "onion", "cheese", "olives"}),
                new MyMealTestData("dinner", "pumpkin soup", new String[]{"pumpkin", "coconut milk", "curry", "carrots"}),
                new MyMealTestData("dinner", "beef steak", new String[]{"beef steak"}),
                new MyMealTestData("dinner", "pizza", new String[]{"flour", "tomato", "cheese", "salami"}),
                new MyMealTestData("dinner", "tomato soup", new String[]{"tomato", "orzo"})
        };
      
        void checkTableSchema(List<dbTable> tables) {
          try {
            Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);
            DatabaseMetaData meta = connection.getMetaData();
            for (dbTable table : tables) {
              ResultSet tableMeta = meta.getTables(null, null, table.name, null);
              if (!tableMeta.next() || !table.name.equalsIgnoreCase(tableMeta.getString("TABLE_NAME"))) {
                throw new WrongAnswer("The table \"" + table.name + "\" doesn't exist.");
              }
              ResultSet columns = meta.getColumns(null, null, table.name, null);
              List<Column> columnsData = new ArrayList<>();
              while (columns.next()) {
                Column column = new Column(
                        columns.getString("COLUMN_NAME").toLowerCase(),
                        columns.getString("TYPE_NAME").toLowerCase());
                columnsData.add(column);
              }
              for (Column c : table.columnNameType) {
                if (!columnsData.contains(c)) {
                  for (Column c2 : columnsData) {
                    if (c.first.equals(c2.first)) {
                      throw new WrongAnswer("The column \"" + c.first + "\" of the table \"" + table.name + "\" is of the " +
                              "wrong type.");
                    }
                  }
                  throw new WrongAnswer("The column \"" + c.first + "\" of the table \"" + table.name + "\" doesn't exist.");
                }
              }
            }
            connection.close();
          } catch (Exception e) {
            throw new WrongAnswer("An exception was thrown, while trying to check the database schema - " + e.getMessage());
          }
        }
      
        void checkConnection() {
          try {
            Class.forName("org.postgresql.Driver");
          } catch (ClassNotFoundException e) {
            throw new WrongAnswer("An exception was thrown, while trying to connect to database. PostgreSQL JDBC Driver is " +
                    "not found.");
          }
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (SQLException e) {
            throw new WrongAnswer("An exception was thrown, while trying to connect to database. Connection Failed");
          }
      
          if (connection == null) {
            throw new WrongAnswer("Failed to make connection to database");
          }
        }
      
        @DynamicTest(order = 1)
        public CheckResult normalExe12Test() {
      
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          CheckOutput co = new CheckOutput();
          if (!co.start("What would you like to do (add, show, plan, exit)?"))
            return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, exit)" +
                    "?\"");
          ArrayList<dbTable> tables = new ArrayList<>(Arrays.asList(
                  new dbTable("ingredients", new ArrayList<>(
                          Arrays.asList(
                                  new Column("ingredient", "varchar"),
                                  new Column("ingredient_id", "int4"),
                                  new Column("meal_id", "int4")
                          )
                  )),
                  new dbTable("meals", new ArrayList<>(
                          Arrays.asList(
                                  new Column("category", "varchar"),
                                  new Column("meal", "varchar"),
                                  new Column("meal_id", "int4")
                          )
                  ))
          ));
          checkTableSchema(tables);
      
          if (!co.input("exit", "Bye!"))
            return CheckResult.wrong("Your output should contain \"Bye!\"");
          if (!co.programIsFinished())
            return CheckResult.wrong("The application didn't exit.");
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 2)
        CheckResult normalExe13Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, dinner)" +
                      "?\"");
      
            if (!co.input("lunch", "Input the meal's name:"))
              return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
            if (!co.input("sushi", "Input the ingredients:"))
              return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
            if (!co.input("salmon, rice, avocado", "The meal has been added!"))
              return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, dinner)" +
                      "?\"");
      
            if (!co.input("lunch", "Input the meal's name:"))
              return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
            if (!co.input("omelette", "Input the ingredients:"))
              return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
            if (!co.input("eggs, milk, cheese", "The meal has been added!"))
              return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, dinner)" +
                      "?\"");
      
            if (!co.input("breakfast", "Input the meal's name:"))
              return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
            if (!co.input("oatmeal", "Input the ingredients:"))
              return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
            if (!co.input("oats, milk, banana, peanut butter", "The meal has been added!"))
              return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("lunch", "Category: lunch", "Name: sushi", "Ingredients:", "salmon", "rice", "avocado",
                    "Name: omelette", "Ingredients:", "eggs", "milk", "cheese"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("breakfast", "Category: breakfast", "Name: oatmeal", "Ingredients:", "oats",
                    "milk", "banana", "peanut butter"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - " + e);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 3)
        CheckResult normalExe14Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("lunch", "Category: lunch", "Name: sushi", "Ingredients:", "salmon", "rice", "avocado",
                    "Name: omelette", "Ingredients:", "eggs", "milk", "cheese"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("breakfast", "Category: breakfast", "Name: oatmeal", "Ingredients:", "oats",
                    "milk", "banana", "peanut butter"))
              return CheckResult.wrong("Wrong \"show\" output for a saved meal.");
      
            if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
            if (!co.input("show", "Which category do you want to print (breakfast, lunch, dinner)?"))
              return CheckResult.wrong("Your program should ask the user about the meal category to print: \"(breakfast, " +
                      "lunch, dinner)?\"");
      
            if (!co.input("brunch", "Wrong meal category! Choose from: breakfast, lunch, dinner."))
              return CheckResult.wrong("Wrong output after the input of a category that doesn't exist.");
      
            if (!co.input("dinner", "No meals found."))
              return CheckResult.wrong("Wrong output for a category with no added meals.");
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - " + e);
          }
      
          return CheckResult.correct();
        }
      
        @DynamicTest(order = 4)
        CheckResult normalExe15Test() {
          checkConnection();
          Connection connection = null;
          try {
            connection = DriverManager.getConnection(DB_URL, USER, PASS);
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to connect to database. Connection Failed");
          }
          try {
            Statement statement = connection.createStatement();
            statement.executeUpdate("DROP TABLE if exists ingredients");
            statement.executeUpdate("DROP TABLE if exists plan");
            statement.executeUpdate("DROP TABLE if exists meals");
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown, while trying to drop tables - " + e);
          }
      
          try {
            CheckOutput co = new CheckOutput();
            if (!co.start("What would you like to do (add, show, plan, exit)?"))
              return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                      "exit)?\"");
      
      
            for (MyMealTestData meal : mealsList) {
              if (!co.input("add", "Which meal do you want to add (breakfast, lunch, dinner)?"))
                return CheckResult.wrong("Your program should ask the user about meal category: \"(breakfast, lunch, " +
                        "dinner)?\"");
      
              if (!co.input(meal.mealCategory, "Input the meal's name:"))
                return CheckResult.wrong("Your output should contain \"Input the meal's name:\"");
      
              if (!co.input(meal.mealName, "Input the ingredients:"))
                return CheckResult.wrong("Your output should contain \"Input the ingredients:\"");
      
              if (!co.input(String.join(",", meal.ingredients), "The meal has been added!"))
                return CheckResult.wrong("Your output should contain \"The meal has been added!\"");
      
              if (!co.inputNext("What would you like to do (add, show, plan, exit)?"))
                return CheckResult.wrong("Your program should ask the user about the required action: \"(add, show, plan, " +
                        "exit)?\"");
      
            }
      
            co.getNextOutput("plan");
            int index = 0;
            for (String day : days) {
              if (!co.inputNext(day))
                return CheckResult.wrong("Your output should contain \"" + day + "\"");
      
              String[] categories = new String[]{"breakfast", "lunch", "dinner"};
              String[][] alphabetic = {
                      new String[]{"english breakfast", "oatmeal", "sandwich", "scrambled eggs"},
                      new String[]{"chicken salad", "omelette", "salad", "sushi"},
                      new String[]{"beef steak", "pizza", "pumpkin soup", "tomato soup"}
              };
              for (int i = 0; i < 3; i++) {
                String category = categories[i];
                if (!co.inputNext(alphabetic[i]))
                  return CheckResult.wrong("Make sure that formatting of your output is similar to the one in the example. " +
                          "Also, your output should contain the meals in alphabetic order.");
      
                if (!co.inputNext("Choose the " + category + " for " + day + " from the list above:"))
                  return CheckResult.wrong("Your output should contain the prompt for the " + category + " meal.");
      
                if (!co.input("nonExistMeal", "This meal doesn’t exist. Choose a meal from the list above."))
                  return CheckResult.wrong("Your output should contain \"This meal doesn’t exist. Choose a meal from the " +
                          "list above.\"");
      
                co.getNextOutput(((MyMealTestData) (Arrays.stream(mealsList).filter(x -> x.mealCategory.equals(category)).toArray()[index % 4])).mealName);
              }
              if (!co.inputNext("Yeah! We planned the meals for " + day + "."))
                return CheckResult.wrong("Your output should contain \"Yeah! We planned the meals for " + day + ".\".");
              index++;
            }
      
            String[] planPrintout = new String[]{"Monday", "Breakfast: scrambled eggs", "Lunch: sushi", "Dinner: pumpkin " +
                    "soup",
                    "Tuesday", "Breakfast: sandwich", "Lunch: chicken salad", "Dinner: beef steak",
                    "Wednesday", "Breakfast: oatmeal", "Lunch: omelette", "Dinner: pizza",
                    "Thursday", "Breakfast: english breakfast", "Lunch: salad", "Dinner: tomato soup",
                    "Friday", "Breakfast: scrambled eggs", "Lunch: sushi", "Dinner: pumpkin soup",
                    "Saturday", "Breakfast: sandwich", "Lunch: chicken salad", "Dinner: beef steak",
                    "Sunday", "Breakfast: oatmeal", "Lunch: omelette", "Dinner: pizza"};
      
            for (String line : planPrintout) {
              if (!co.inputNext(line))
                return CheckResult.wrong("Your output should contain \"" + line + "\".");
            }
      
            if (!co.input("exit", "Bye!"))
              return CheckResult.wrong("Your output should contain \"Bye!\"");
      
            if (!co.programIsFinished())
              return CheckResult.wrong("The application didn't exit.");
      
          } catch (Exception e) {
            return CheckResult.wrong("An exception was thrown while testing - " + e);
          }
      
          return CheckResult.correct();
        }
      
      }
      
      
      class CheckOutput {
        private TestedProgram main = new TestedProgram();
        private int position = 0;
        private boolean caseInsensitive = true;
        private boolean trimOutput = true;
        private List<String> arguments = new ArrayList<>();
        private boolean isStarted = false;
        private String lastOutput = "";
      
        private boolean checkOutput(String outputString, String... checkStr) {
          int searchPosition = position;
          for (String cStr : checkStr) {
            String str = caseInsensitive ? cStr.toLowerCase() : cStr;
            int findPosition = outputString.indexOf(str, searchPosition);
            if (findPosition == -1) return false;
            if (!outputString.substring(searchPosition, findPosition).isBlank()) return false;
            searchPosition = findPosition + str.length();
          }
          position = searchPosition;
          return true;
        }
      
        public boolean start(String... checkStr) {
          if (isStarted)
            return false;
          var outputString = main.start(arguments.toArray(new String[]{}));
          lastOutput = outputString;
          if (trimOutput) outputString = outputString.trim();
          if (caseInsensitive) outputString = outputString.toLowerCase();
          isStarted = true;
          return checkOutput(outputString, checkStr);
        }
      
        public void stop() {
          main.stop();
        }
      
        public boolean input(String input, String... checkStr) {
          if (main.isFinished()) return false;
          String outputString = main.execute(input);
          lastOutput = outputString;
          if (trimOutput) outputString = outputString.trim();
          if (caseInsensitive) outputString = outputString.toLowerCase();
          position = 0;
          return checkOutput(outputString, checkStr);
        }
      
        public boolean inputNext(String... checkStr) {
          String outputString = lastOutput;
          if (trimOutput) outputString = outputString.trim();
          if (caseInsensitive) outputString = outputString.toLowerCase();
          return checkOutput(outputString, checkStr);
        }
      
        public String getNextOutput(String input) {
          if (main.isFinished()) return "";
          String outputString = main.execute(input);
          lastOutput = outputString;
          position = 0;
          return outputString;
        }
      
        public String getLastOutput() {
          return lastOutput;
        }
      
        public boolean programIsFinished() {
          return main.isFinished();
        }
      
        public void setArguments(String... arguments) {
          this.arguments = Arrays.stream(arguments).toList();
        }
      
        public void setCaseInsensitive(boolean caseInsensitive) {
          this.caseInsensitive = caseInsensitive;
        }
      
        public void setTrimOutput(boolean trimOutput) {
          this.trimOutput = trimOutput;
        }
      }
    learner_created: false
  - name: src/mealplanner/main/MealUserInput.java
    visible: true
    text: |
      package mealplanner.main;
      
      import java.util.Scanner;
      import java.util.regex.Matcher;
      import java.util.regex.Pattern;
      
      /**
       * This class is specific to this program. It gets valid user input, but the methods are specific to what this program needs.
       */
      
      public class MealUserInput {
          /**
           * This enum ensures that user input for what operation to do is correct
           */
          private enum Operations {
              ADD("add"), SHOW("show"), EXIT("exit");
              private final String operation;
      
              Operations(String operation) {
                  this.operation = operation;
              }
      
              private String getOperation() {
                  return this.operation;
              }
          }
      
          /**
           * This enum ensures that user input for a meal category is correct
           */
          public enum Categories {
              BREAKFAST("breakfast"), LUNCH("lunch"), DINNER("dinner");
              private final String category;
      
              Categories(String category) {
                  this.category = category;
              }
      
              private String getCategory() {
                  return this.category;
              }
          }
      
          private static final Scanner scanner = new Scanner(System.in);
      
          /**
           * Gets a valid operation from user input. Will keep looping until the user inputs a valid operation
           * @return = the operation
           */
          static String getValidOperation() {
              while (true) {
                  String operation = scanner.nextLine();
                  for (Operations enumOperation : Operations.values()) {
                      if (enumOperation.getOperation().equals(operation)) {
                          return operation;
                      }
                  }
                  System.out.println("What would you like to do (add, show, exit)?");
              }
          }
      
          /**
           * Gets a valid meal category from user input. Will keep looping until the user inputs a valid category
           * @return = the category
           */
          static String getValidCategory() {
              while (true) {
                  String category = scanner.nextLine();
                  for (Categories enumCategory : Categories.values()) {
                      if (enumCategory.getCategory().equals(category)) {
                          return category;
                      }
                  }
                  System.out.println("Wrong meal category! Choose from: breakfast, lunch, dinner.");
              }
          }
      
          /**
           * Gets a valid array of ingredients from user input. Will keep looping until the user inputs a valid ingredients array
           * @return = the array of ingredients
           */
          static String[] getValidIngredients() {
              // This regex matches anything other than letters and whitespace. So if it matches anything in the input, the input is wrong
              String lettersRegex = "[^a-zA-Z\\s]";
              // This regex matches anything other than whitespace. So if it matches nothing in the input, the input is wrong
              String emptyRegex = "\\S";
              // Pattern for the letters regex
              Pattern lettersPattern = Pattern.compile(lettersRegex);
              // Pattern for the empty regex
              Pattern emptyPattern = Pattern.compile(emptyRegex);
              whileloop:
              while (true) {
                  String userInputString = scanner.nextLine();
                  // Checks the corner case of there being a comma at the end of the input
                  if (userInputString.length() >= 2) {
                      if (userInputString.substring(userInputString.length() - 2).matches(",|, ")) {
                          System.out.println("Wrong format. Use letters only!");
                          continue;
                      }
                  }
                  String[] userInput = userInputString.split(", ");
                  for (String ingredient : userInput) {
                      Matcher lettersMatcher = lettersPattern.matcher(ingredient);
                      Matcher emptyMatcher = emptyPattern.matcher(ingredient);
                      // Checks each element in the split array rather than the entire inputted string
                      if (lettersMatcher.find() || !emptyMatcher.find()) {
                          System.out.println("Wrong format. Use letters only!");
                          continue whileloop;
                      }
                  }
                  return userInput;
              }
          }
      }
    learner_created: true
  - name: src/mealplanner/userinput/UserInput.java
    visible: true
    text: |-
      package mealplanner.userinput;
      
      import java.util.Scanner;
      import java.util.regex.Matcher;
      import java.util.regex.Pattern;
      
      /**
       * This class is a general purpose class for getting user input. Methods can be customized with custom error messages
       */
      public class UserInput {
          private static final Scanner scanner = new Scanner(System.in);
      
          /**
           * Gets a string consisting of just letters and whitespace. Will keep looping until the user inputs a correct string
           * @return = the string, as long as it is valid
           */
          public static String getAlphabeticalString(String errorMessage) {
              // This regex matches anything other than letters and whitespace. So if it matches anything in the input, the input is wrong
              String lettersRegex = "[^a-zA-Z\\s]";
              // This regex matches anything other than whitespace. So if it matches nothing in the input, the input is wrong
              String emptyRegex = "\\S";
              // Pattern for the letters regex
              Pattern lettersPattern = Pattern.compile(lettersRegex);
              // Pattern for the empty regex
              Pattern emptyPattern = Pattern.compile(emptyRegex);
              while (true) {
                  String userInput = scanner.nextLine();
                  Matcher lettersMatcher = lettersPattern.matcher(userInput);
                  Matcher emptyMatcher = emptyPattern.matcher(userInput);
                  if (lettersMatcher.find() || !emptyMatcher.find()) {
                      System.out.println(errorMessage);
                      continue;
                  }
                  return userInput;
              }
          }
      }
    learner_created: true
  - name: src/mealplanner/meal/cache/MessageThread.java
    visible: true
    text: |
      package mealplanner.meal.cache;
      
      import mealplanner.meal.datamanager.DataManager;
      
      /**
       * This class is the thread that caches the message to be used with the show operation. This class is used with the MessageCache class.
       */
      @Deprecated
      public class MessageThread extends Thread {
          // Holds the cached message, but it is passed to the MessageCache after the message is cached. This exists just because the run method can only return void
          private String cache;
      
          public MessageThread() {
              super();
          }
      
          @Override
          public void run() {
              cache = DataManager.getMessage("breakfast");
          }
      
          String getCache() {
              return cache;
          }
      }
    learner_created: true
  - name: src/mealplanner/meal/datamanager/legacydatamanager/DataManager.java
    visible: true
    text: |
      package mealplanner.meal.datamanager;
      
      import org.postgresql.ds.PGSimpleDataSource;
      
      import java.sql.Connection;
      import java.sql.PreparedStatement;
      import java.sql.ResultSet;
      import java.sql.SQLException;
      
      /**
       *
       *
       *
       * !!!
       * WARNING!! Read the javadoc for MessageCache.java
       * !!!
       *
       *
       *
       * This class manages the meal database. It lets you get data, insert data, modify data, and read data
       */
      public class DataManager {
          /**
           * This enum is used to ensure that correct tables which exist are being chosen
           */
          public enum Tables {
              MEALS, INGREDIENTS
          }
      
          /**
           * Initializes the required tables if they don't already exist at the beginning of the runtime
           */
          public static void initializeTables() {
              try (Connection connection = connect()) {
                  String mealsTableCreation = "CREATE TABLE IF NOT EXISTS meals (" +
                                                  "category VARCHAR(9)," +
                                                  "meal VARCHAR(50)," +
                                                  "meal_id INTEGER" +
                                              ")";
                  String ingredientsTableCreation = "CREATE TABLE IF NOT EXISTS ingredients (" +
                                                          "ingredient VARCHAR(50)," +
                                                          "ingredient_id INTEGER," +
                                                          "meal_id INTEGER" +
                                                      ")";
                  try (PreparedStatement mealsTableStatement = connection.prepareStatement(mealsTableCreation); PreparedStatement ingredientsTableStatement = connection.prepareStatement(ingredientsTableCreation)) {
                      // Initialization
                      mealsTableStatement.execute();
                      ingredientsTableStatement.execute();
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
          }
      
          /**
           * Returns a ResultSet of all the columns from the specified table
           * @param table the name of the table which the user wishes to select data from
           * @return the ResultSet from the specified table
           */
          @Deprecated
          public static ResultSet getAllColumns(Tables table) {
              try (Connection connection = connect()) {
                  if (table.equals(Tables.MEALS)) {
                      String selection = "SELECT * FROM meals";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(selection)) {
                          return preparedStatement.executeQuery();
                      } catch (SQLException ignored) {
                      }
                  } else if (table.equals(Tables.INGREDIENTS)) {
                      String selection = "SELECT * FROM ingredients";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(selection)) {
                          return preparedStatement.executeQuery();
                      } catch (SQLException ignored) {
                      }
                  }
      
              } catch (SQLException ignored) {
              }
              return null;
          }
      
          /**
           * Returns all the data in the meals table in the specified category as a string for use with the show operation.
           * @param category the category in which only meals from that category are read
           */
          public static String getMessage(String category) {
              StringBuilder message = new StringBuilder();
              // Keeps track of how many meals there are so the spacing is correct. If there is only one meal, there should not be any padding. If there is more than one meal, there should be padding
              int mealCounter = 0;
              // Points to where to place the padding in-between the category and the first name if there is more than one meal
              int firstPaddingPointer = 0;
              try (Connection connection = connect()) {
                  String mealSelection = "SELECT * FROM meals WHERE category = '" + category + "'";
                  String ingredientSelection = "SELECT * FROM ingredients WHERE meal_id = ? ORDER BY ingredient_id";
                  try (PreparedStatement mealStatement = connection.prepareStatement(mealSelection); PreparedStatement ingredientStatement = connection.prepareStatement(ingredientSelection)) {
                      // Result of meal selection
                      try (ResultSet mealData = mealStatement.executeQuery()) {
                          message.append("Category: ").append(category).append("\n");
                          // Places the pointer in-between the category and the first name
                          firstPaddingPointer = message.length();
                          while (mealData.next()) {
                              ++mealCounter;
                              message.append("Name: ").append(mealData.getString("meal")).append("\n");
                              message.append("Ingredients: \n");
                              ingredientStatement.setInt(1, mealData.getInt("meal_id"));
                              try (ResultSet ingredientData = ingredientStatement.executeQuery()) {
                                  while (ingredientData.next()) {
                                      message.append(ingredientData.getString("ingredient")).append("\n");
                                  }
                              } catch (Exception ignored) {
                              }
                              message.append("\n");
                          }
                      } catch (SQLException ignored) {
                      }
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
              // Adds finishing touches to the message based on how many meals there are
              if (mealCounter == 0) {
                  return "No meals found.";
              } else if (mealCounter == 1) {
                  // Removes all the padding at the end of the message so the message is flush with the next operation request
                  message.delete(message.length() - 2, message.length());
              } else {
                  // Adds the first padding at the pointer
                  message.insert(firstPaddingPointer, "\n");
                  // Deletes the extra newline so there aren't two newlines at the end
                  message.delete(message.length() - 1, message.length());
              }
              return message.toString();
          }
      
          /**
           * Inserts passed data into the specified table. Uses the Tables enum to specify which table it should insert the data into. The data is parsed differently depending on which table it is being
           * put into
           * @param table the table that the user wants to insert data into
           * @param values a string array consisting of all data the user wants to insert
           */
          public static void insertInto(Tables table, String[] values) {
              try (Connection connection = connect()) {
                  // If the passed table is the meals table, then the data is parsed specially for that table
                  if (table.equals(Tables.MEALS)) {
                      String insert = "INSERT INTO meals VALUES(?, ?, ?)";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(insert)) {
                          preparedStatement.setString(1, values[0]);
                          preparedStatement.setString(2, values[1]);
                          preparedStatement.setInt(3, Integer.parseInt(values[2]));
                          preparedStatement.executeUpdate();
                      } catch (SQLException e) {
                          e.getMessage();
                      }
                  // If the passed table is the ingredients table, then the data is parsed specially for that table
                  } else if (table.equals(Tables.INGREDIENTS)) {
                      String insert = "INSERT INTO ingredients VALUES(?, ?, ?)";
                      try (PreparedStatement preparedStatement = connection.prepareStatement(insert)) {
                          preparedStatement.setString(1, values[0]);
                          preparedStatement.setInt(2, Integer.parseInt(values[1]));
                          preparedStatement.setInt(3, Integer.parseInt(values[2]));
                          preparedStatement.executeUpdate();
                      } catch (SQLException e) {
                          e.getMessage();
                      }
                  }
              } catch (SQLException e) {
                  e.getMessage();
              }
          }
      
          /**
           * Gets the next meal id to be used when adding a meal to the database
           * @return the meal id
           */
          public static int getNextMealID() {
              try (Connection connection = connect()) {
                  String selection = "SELECT MAX(meal_id) FROM meals";
                  try (PreparedStatement statement = connection.prepareStatement(selection)) {
                      try (ResultSet result = statement.executeQuery()) {
                          result.next();
                          return result.getInt("max") + 1;
                      } catch (SQLException ignored) {
                      }
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
              return 0;
          }
      
          /**
           * Gets the next ingredient id to be used when adding an ingredient to the database
           * @return the ingredient id
           */
          public static int getNextIngredientID() {
              try (Connection connection = connect()) {
                  String selection = "SELECT MAX(ingredient_id) FROM ingredients";
                  try (PreparedStatement statement = connection.prepareStatement(selection)) {
                      try (ResultSet result = statement.executeQuery()) {
                          result.next();
                          return result.getInt("max") + 1;
                      } catch (SQLException ignored) {
                      }
                  } catch (SQLException ignored) {
                  }
              } catch (SQLException ignored) {
              }
              return 0;
          }
      
          /**
           * Returns a connection object to be used in other methods. Needs to be used to a try-catch block because one is not used here
           * @return the connection object
           * @throws SQLException;
           */
          private static Connection connect() throws SQLException {
              String DB_URL = "jdbc:postgresql:meals_db";
              String USER = "postgres";
              String PASS = "1111";
              PGSimpleDataSource dataSource = new PGSimpleDataSource();
              dataSource.setURL(DB_URL);
              dataSource.setUser(USER);
              dataSource.setPassword(PASS);
              return dataSource.getConnection(USER, PASS);
          }
      }
    learner_created: true
  - name: src/mealplanner/main/Main.java
    visible: true
    text: |-
      package mealplanner.main;
      
      import mealplanner.meal.datamanager.DataManager;
      import mealplanner.userinput.UserInput;
      
      public class Main {
        public static void main(String[] args) {
          // Since the test gets rid of all tables at the start of execution, I need to initialize the tables if they don't already exist
          DataManager.initializeTables();
          // The user input loop
          inputLoop();
        }
      
        /**
         * This is the loop for getting user input and performing actions
         */
        private static void inputLoop() {
          // The while loop uses this boolean as the condition, so when this boolean is set to false, the loop terminates
          boolean shouldContinue = true;
          while (shouldContinue) {
            //String message = DataManager.getMessage();
            // Caches the message
            System.out.println("What would you like to do (add, show, exit)?");
            String operation = MealUserInput.getValidOperation();
            switch (operation) {
              case "add":
                addMeal();
                break;
              case "show":
                showMeals();
                break;
              case "exit":
                shouldContinue = false;
                System.out.println("Bye!");
            }
          }
        }
      
        /**
         * Adds a new meal to the savedMeals ArrayList. Uses user input classes to get valid input
         */
        private static void addMeal() {
          System.out.println("Which meal do you want to add (breakfast, lunch, dinner)?");
          String category = MealUserInput.getValidCategory();
          System.out.println("Input the meal's name:");
          String name = UserInput.getAlphabeticalString("Wrong format. Use letters only!");
          System.out.println("Input the ingredients:");
          String[] ingredients = MealUserInput.getValidIngredients();
          String mealID = Integer.toString(DataManager.getNextMealID());
          DataManager.insertInto(DataManager.Tables.MEALS, new String[]{category, name, mealID});
          for (String ingredient : ingredients) {
            DataManager.insertInto(DataManager.Tables.INGREDIENTS, new String[]{ingredient, Integer.toString(DataManager.getNextIngredientID()), mealID});
          }
          System.out.println("The meal has been added!");
        }
      
        /**
         * Shows all meals in the category specified by the user
         */
        private static void showMeals() {
          System.out.println("Which category do you want to print (breakfast, lunch, dinner)?");
          System.out.println(DataManager.getMessage(MealUserInput.getValidCategory()));
        }
      }
    learner_created: true
  - name: src/mealplanner/meal/cache/MessageCache.java
    visible: true
    text: |
      package mealplanner.meal.cache;
      
      /**
       *
       *
       *
       * !!!
       * WARNING!! I realized that this whole cache system doesn't work as a thread. Yes, this class uses threads, but main still has to wait for the cache method to complete as this class does
       * not extend Thread. And I tried to get the system to work as a thread, but I couldn't get it to work, so I gave up.
       * !!!
       *
       *
       *
       * This class caches the message to be used with the show operation. It doesn't actually do the caching here. Rather, it uses a MessageThread to cache it. This is so it can use a thread to cache
       * the message while remaining live. If this class was the one which cached the message, then the thread would die after the first cache. So, this class simply creates a new thread everytime it
       * needs to cache the message and discards it afterward.
       */
      @Deprecated
      public class MessageCache {
          // Holds the cached message
          private static String cache;
      
          /**
           * Caches the message
           * @throws InterruptedException;
           */
          public void cache() throws InterruptedException {
              MessageThread thread = new MessageThread();
              thread.start();
              // If the thread isn't joined, then cache might be set to null
              thread.join();
              cache = thread.getCache();
          }
      
          public String getCache() {
              return cache;
          }
      }
    learner_created: true
  - name: src/mealplanner/meal/datamanager/dao/plan/PlanDao.java
    visible: true
    learner_created: true
  - name: src/mealplanner/meal/datamanager/dao/plan/DbPlanDao.java
    visible: true
    learner_created: true
  - name: src/mealplanner/meal/datamanager/dao/plan/DbPlanClient.java
    visible: true
    learner_created: true
  - name: src/mealplanner/meal/datamanager/dao/plan/Plan.java
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/25575#comment
status: Solved
feedback:
  message: Congratulations!
  time: "Sat, 23 Mar 2024 13:40:34 UTC"
record: 4
